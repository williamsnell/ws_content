<!DOCTYPE html>
<head>
<script src="https://cdn.plot.ly/plotly-2.32.0.min.js" charset="utf-8"></script>
</head>
<body>
<div id="plot" style="width: 1000px; height: 600px;"></div>
<div id="benchmark"></div>
<script>
// generate points
class Node {
    constructor(val, less_than, greater_than) {
        this.val = val;
        this.less_than = less_than;
        this.greater_than = greater_than;
    }
}

class KDTree {
    constructor(points) {
        this.n_dimensions = points[0].length;
        this.tree = this.build_tree(points, 0, this.n_dimensions);
    }
    build_tree(points, dim, n_dims) {
        if (points.length == 1) {
            return new Node(points[0], null, null);
        }
        // sort a subset of the points
        const n_subset = Math.min(points.length, Math.min(200, Math.max(10, parseInt(points.length / 10))));
        //const n_subset = points.length;
        // assume the area is homogeneous, so we can
        // just pick the first n_subset points.
        let subset = points.slice(0, Math.min(points.length, n_subset)).map((x, i) => x.concat([i]));
        subset.sort((a, b) => a[dim] - b[dim]);
        let midpoint = subset[parseInt(subset.length / 2)][subset[0].length - 1];
        let median = points[midpoint];
        let median_elem = median[dim];
        // Remove the median so we don't count it twice.
        points.splice(midpoint, 1);
        
        let next_dim = (dim + 1) % n_dims;

        let points_leq = points.filter((x) => x[dim] <= median_elem);
        let points_gt = points.filter((x) => x[dim] > median_elem);

        let less_than, greater_than;
        
        if (points_leq.length > 0) {
            less_than = this.build_tree(points_leq, next_dim, n_dims);
        }
        if (points_gt.length > 0) {
            greater_than = this.build_tree(points_gt, next_dim, n_dims);
        }

        return new Node(median, less_than, greater_than);
    }

    knn(point, k, return_dist=false) {
        let closest_points = []; // [[distance, *point]]
        let n_dimensions = this.n_dimensions;

        function distance(x, y, norm=Math.inf) {
            if (norm == Math.inf) {
                return Math.max(...x.map((x, i) => Math.abs(x - y[i])));
            }
            return x.reduce((partial_sum, x, i) => partial_sum + (x-y[i])**norm, 0);
        }

        // find the point where the 

        function find_closest(node, dim=0) {
            let match = node.val;

            let gt = point[dim] > node.val[dim];

            if (node.greater_than && gt) {
                find_closest(node.greater_than, (dim + 1) % n_dimensions);
            } else if (node.less_than && !gt) {
                find_closest(node.less_than, (dim + 1) % n_dimensions);
            }

            // At this point, we've greedily explored on the 
            // "best" side of the tree.
            let dist = distance(point, match);

            if (closest_points.length < k) {
                closest_points.push([dist].concat(match));
            } else if (dist < closest_points[0][0]) {
                closest_points[0] = [dist].concat(match);
            }
            closest_points.sort((a, b) => b[0] - a[0]);
            
            // Check if the distance to the splitting plane
            // is less than the distance to the furthest
            // neighbor.
            if (closest_points[0][0] > distance([point[dim]], [node.val[dim]])) {
                // If so, traverse the opposite tree to last time.
                    if (node.greater_than && !gt) {
                    find_closest(node.greater_than, (dim + 1) % n_dimensions);
                } else if (node.less_than && gt) {
                    find_closest(node.less_than, (dim + 1) % n_dimensions);
                }
            }

            return node.val;
        }

        find_closest(this.tree);
        if (return_dist) {
            return [closest_points.map((x) => x.slice(1)), closest_points.map((x) => x[0])];
        }
        return closest_points.map((x) => x.slice(1));
    }
}
let tree;

let n_points = 10_000;
let x = Array(n_points).fill(0).map((x) => Math.random() * 80);
let y = Array(n_points).fill(0).map((x) => (Math.random()  - 0.5) * 50);
let z = x.map((x, i) => Math.sin(x / 20) * 20 + y[i] + Math.random() * 10);
let points = x.map((x, i) => [x, y[i], z[i]]);

const n_repeats = 1;

let start_build_tree = Date.now();
for (let i = 0; i < n_repeats; i++) {
    tree = new KDTree(points);
}

let build_time = (Date.now() - start_build_tree) / n_repeats;

let [neighbors, dists] = tree.knn(points[0], 7, true);

let start_knn_search = Date.now();
for (let i = 0; i < n_repeats; i++) {
    points.map((x) => tree.knn(x, 3));
}

let search_time = (Date.now() - start_knn_search) / n_repeats;


// calculate the surface of a sphere for the nearest neighbors
function calc_sphere(cx, cy, cz, radius, n=30) {
    let x = [];
    let y = [];
    let z = [];
    // Create a hemisphere
    for (let i = 0; i < 2 * Math.PI; i += 2 * Math.PI / n) {
        for (let j = 0; j < Math.PI; j += 2 * Math.PI / n) {
            let cj = Math.cos(j);
            x.push(cx + radius * Math.sin(i) * cj);
            y.push(cy + radius * Math.cos(i) * cj);
            z.push(cz + radius * Math.sin(j));
        }
    }

    // Return the two hemispheres
    return [[x, y, z], [x, y, z.map((z) => 2 * cz -z)]];
}

function cube(cx, cy, cz, edge_length) {
    let l = edge_length;
    return {
        x: [cx - l, cx - l,  cx + l, cx + l, cx - l, cx - l, cx + l, cx + l],
        y: [cy - l, cy + l, cy + l, cy - l, cy - l, cy + l, cy + l, cy - l],
        z: [cz - l, cz - l, cz - l, cz - l, cz + l, cz + l, cz + l, cz + l],
        i: [7, 0, 0, 0, 4, 4, 6, 6, 4, 0, 3, 2],
        j: [3, 4, 1, 2, 5, 6, 5, 2, 0, 1, 6, 3],
        k: [0, 7, 2, 3, 6, 7, 1, 1, 5, 5, 7, 6],
    }
}

// let [[sx, sy, sz], [sx2, sy2, sz2]] = calc_sphere(points[0][0], points[0][1], points[0][2], dists[0]**0.5);
let surf = cube(points[0][0], points[0][1], points[0][2], dists[0]);
surf.opacity = 0.1;
surf.color = "blue";
surf.type = "mesh3d";

Plotly.newPlot('plot', [
    {
        x: x, 
        y: y, 
        z: z,
        mode: 'markers',
        marker: {
            size: 0.5,
            color: "black",
        },
        type: 'scatter3d',
    },
    {
        x: neighbors.map((x) => x[0]),
        y: neighbors.map((x) => x[1]),
        z: neighbors.map((x) => x[2]),
        mode: 'markers',
        marker: {
            size: 1,
            color: "orange"
        },
        type: 'scatter3d',
    },
    {
        x: [points[0][0]],
        y: [points[0][1]],
        z: [points[0][2]],
        mode: 'markers',
        marker: {
            size: 2,
            color: "red"
        },
        type: 'scatter3d',
    },
    surf
],
    {
        width: 1200,
        height: 600,
        margin: {t: 0, l: 0, r: 0, b: 0},
        xaxis: {
            scaleanchor: 'y'
        }
    }
);
document.getElementById('benchmark').textContent = `
Build: ${build_time}ms
KNN-search: ${search_time}ms
`;

</script>

</body>
